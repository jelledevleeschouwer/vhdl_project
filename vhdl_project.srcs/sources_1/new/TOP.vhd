----------------------------------------------------------------------------------
-- Company:
-- Engineer: Carleer Jasper & Jelle De Vleesshouwer
--
-- Create Date: 11/29/2016 03:41:01 PM
-- Design Name:
-- Module Name: TOP - Behavioral
-- Project Name:
-- Target Devices:
-- Tool Versions:
-- Description:
--
-- Dependencies:
--
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
--
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.all;

-- Library that provides the functionality of IP (PLL)
library UNISIM;
use UNISIM.vcomponents.all;

entity TOP is
    Port (
        CLK     :in  STD_LOGIC;  -- 125 MHz
        RST     :in  STD_LOGIC;

        -- Control signals of display
        P_CLK   :out STD_LOGIC;  -- 9 MHz
        H_SYNC  :out STD_LOGIC;
        V_SYNC  :out STD_LOGIC;
        RED     :out STD_LOGIC_VECTOR (7 downto 0);
        GREEN   :out STD_LOGIC_VECTOR (7 downto 0);
        BLUE    :out STD_LOGIC_VECTOR (7 downto 0);
        DISP_EN :out STD_LOGIC;
        BL_EN   :out STD_LOGIC;
        GND     :out STD_LOGIC;

        -- SPI
        CS      :out STD_LOGIC;
        DCLK    :out STD_LOGIC;
        MOSI    :out STD_LOGIC;
        MISO    :in STD_LOGIC;
        BUSY    :in STD_LOGIC
    );
end TOP;

architecture Behavioral of TOP is

---------------------------------------
-- Declaration of the components
---------------------------------------

-- 9 MHz PLL
component PLL_9MHz is
    Port (
        CLK     :in  STD_LOGIC;     -- 125 MHz
        RST     :in  STD_LOGIC;
        CLK_9MHz:out STD_LOGIC      -- 9 MHz
    );
end component;

-- Display driver (timing)
component display_driver is
    Port (
        -- This should be a 9MHz clock generated by a PLL
        P_CLK   :in  STD_LOGIC;
        RST     :in  STD_LOGIC;

        -- Timing signals for the display
        H_SYNC  :out STD_LOGIC;
        V_SYNC  :out STD_LOGIC;
        DISP_EN :out STD_LOGIC;

        -- Control signals for the game
        VALID   :out STD_LOGIC;
        X_POS   :out STD_LOGIC_VECTOR (8 downto 0); -- Valid only if DISP_EN = '1';
        Y_POS   :out STD_LOGIC_VECTOR (8 downto 0)  -- Valid only if DISP_EN = '1';
    );
end component;

-- SPI Driver (touch interface)
component touch_driver_picoblaze is
    Port (
        CS   : out std_logic;                    -- Chip Select (Active low)
        DCLK : out std_logic;                    -- SPI Clock
        MOSI : out std_logic;                    -- MOSI
        VALID: out std_logic;                    -- Valid touch detected
        BUSY : in std_logic;                     -- Busy from touch panel (conversion)
        MISO : in std_logic;                     -- MISO
        CLK  : in std_logic;                     -- 125 MHz for PicoBlaze
        RST  : in std_logic;                     -- RST for PicoBlaze
        X_POS: out std_logic_vector(8 downto 0); -- X-position of touch (valid only if VALID='1')
        Y_POS: out std_logic_vector(8 downto 0)  -- Y-position of touch (valid only if VALID='1')
    );
end component;

-- Dual port ram for block storage
component dual_prt_ram_block_strg is
  Port (
      clka  : IN STD_LOGIC;
      wea   : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
      addra : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
      dina  : IN STD_LOGIC_VECTOR(28 DOWNTO 0);
      douta : OUT STD_LOGIC_VECTOR(28 DOWNTO 0);
      clkb  : IN STD_LOGIC;
      web   : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
      addrb : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
      dinb  : IN STD_LOGIC_VECTOR(28 DOWNTO 0);
      doutb : OUT STD_LOGIC_VECTOR(28 DOWNTO 0)
  );
end component;

-- "Draws" blocks that are fetched from block RAM: Uses port B of the dual port RAM
-- Also does collision detection with player and drawn blocks
component draw_blocks is
    Port (
        CLK      : in  STD_LOGIC;                     -- 125 MHz
        RST      : in  STD_LOGIC;

        -- To check whether blocks are visible
        XPOS     : in  STD_LOGIC_VECTOR(8  downto 0); -- Current X-position of draw cursor
        YPOS     : in  STD_LOGIC_VECTOR(8  downto 0); -- Current Y-position of draw cursor
        DISP_EN  : in  STD_LOGIC;                     -- Draw cursor is in visible portion

        -- Signals relating the dual port RAM
        POS_FIRST: in  STD_LOGIC_VECTOR(3 downto 0);  -- Offset where driver has to read from
        DOUT_B   : in  STD_LOGIC_VECTOR(28 downto 0); -- Block structure read from RAM
        ADDR_B   : out STD_LOGIC_VECTOR(3  downto 0); -- Address applied to dual port RAM

        -- Signal relating collision detection
        LANE     : in STD_LOGIC_VECTOR(1 downto 0);   -- Lane player is currently in
        LOST     : out STD_LOGIC;                     -- Collision detected, player lost

        -- Signal to indicate a block is currently visble
        SHOW     : out STD_LOGIC                      -- Control signal applied to color-MUX
    );
end component;

-- Component that moves all the blocks in the block ram: uses port B of the dual port ram
component move_blocks is
    Port (
        CLK      : in  STD_LOGIC;                     -- 125 MHz
        RST      : in  STD_LOGIC;
        V_SYNC   : in  STD_LOGIC;                     -- Update signal (off-screen)
        DOUT_B   : in  STD_LOGIC_VECTOR(28 downto 0); -- Block structure read from block RAM
        DIN_B    : out STD_LOGIC_VECTOR(28 downto 0); -- New block structure to write into block RAM
        WE_B     : out STD_LOGIC_VECTOR(0 downto 0);  -- Write strobe
        ADDR_B   : out STD_LOGIC_VECTOR(3 downto 0)   -- Address applied to block RAM
    );
end component;

-- Block generator: uses port A of the dual port ram
component block_generator is
    Port (
        CLK        : in STD_LOGIC;                      -- 125 MHz
        RST        : in STD_LOGIC;

        -- Signal relating generating blocks
        RAND_NUM   : in std_logic_vector(7 downto 0);   -- Random number, generated by PRNG
        WRITE_EN_A : out std_logic_vector(0 downto 0);  -- Write enable for port A of block RAM
        ADDR_A     : out std_logic_vector(3 downto 0);  -- Address to write the data
        DIN_A      : out std_logic_vector(28 downto 0); -- Data to write to the block ram
        POS_FIRST_O: out std_logic_vector(3 downto 0)   -- Offset where blocks have to be generated (Circular buffer)
    );
end component;

-- Component to draw the background
component background is
    Port (
        CLK      : in STD_LOGIC;                    -- 125 MHz

        X_POS    : in STD_LOGIC_VECTOR(8 downto 0); -- Current X-position of draw cursor
        Y_POS    : in STD_LOGIC_VECTOR(8 downto 0); -- Current Y-position of draw cursor
        VISIBLE  : in STD_LOGIC;                    -- Draw cursor is in visible portion

        SHOW     : out STD_LOGIC                    -- Control signal applied to Color-MUX
    );
end component;

-- Component for position of player, detects in which lane the user touched, generates a SEED-signal
-- for the PRNG and also "draws" the player on screen
component player_driver is
    Generic (
        -- Some parameters to control the touch-areas easily
        area_width   : signed(8 downto 0) := to_signed(192, 9);
        area_height  : signed(8 downto 0) := to_signed(88, 9);
        screen_width : signed(8 downto 0) := to_signed(480, 9);
        screen_height: signed(8 downto 0) := to_signed(272, 9);
        period_pre   : unsigned(19 downto 0) := to_unsigned(1250000, 20)
    );
    Port (
        CLK      : in STD_LOGIC;                      -- 125 MHz
        PCLK     : in STD_LOGIC;                      -- 9 MHz
        RST      : in STD_LOGIC;

        V_SYNC   : in STD_LOGIC;                      -- Update signal (off-screen)

        VALID    : in STD_LOGIC;                      -- Draw cursor is in visible portion
        X_TOUCH  : in STD_LOGIC_VECTOR (8 downto 0);  -- X-coordinate of latest _valid_ touch
        Y_TOUCH  : in STD_LOGIC_VECTOR (8 downto 0);  -- Y-coordinate of latest _valid_ touch
        X_POS    : in STD_LOGIC_VECTOR (8 downto 0);  -- Current X-position of draw cursor
        Y_POS    : in STD_LOGIC_VECTOR (8 downto 0);  -- Current Y-position of draw cursor

        LANE     : out STD_LOGIC_VECTOR (1 downto 0); -- Lane in wich the user has pressed

        PLAYER_R : out STD_LOGIC_VECTOR (7 downto 0); -- Red component to source color-MUX with
        PLAYER_G : out STD_LOGIC_VECTOR (7 downto 0); -- Green component to source color-MUX with
        PLAYER_B : out STD_LOGIC_VECTOR (7 downto 0); -- Blue component to source color-MUX with
        PLAYER_V : out STD_LOGIC;                     -- Control signal to apply to color-MUX

        SEED     : out STD_LOGIC                      -- Seed signal to reiterate PRNG
    );
end component;

-- Component for RNG
component rand_driver is
    Port (
        SEED : in STD_LOGIC;                          -- Trigger signal at random press time
        RAND : out STD_LOGIC_VECTOR (7 downto 0);     -- Random number generated [0, 255]
        CLK : in STD_LOGIC;                           -- 125 MHz
        RST : in STD_LOGIC
    );
end component;

---------------------------------------
-- Constants
---------------------------------------
constant color_delay : integer := 15000000;         -- Delay for color change speed of obstacles

---------------------------------------
-- Signals to internally connect the different components
---------------------------------------

-- For the display driver
signal P_CLK_9MHz : std_logic;                      -- Internal 9 MHz clock
signal X_POS      : std_logic_vector (8 downto 0);  -- Pixel cursor X-coordinate (0-based)
signal Y_POS      : std_logic_vector (8 downto 0);  -- Pixel cursor Y-xoordinate (0-based)
signal VALID      : std_logic;                      -- Draw cursor is in visible portion
signal V_SYNC_SIG : std_logic;                      -- Signal that triggers graphics update

-- Blocks
signal SHOW_BLOCK : std_logic;                      -- Signal to apply to color-MUX
signal red_sig    : std_logic_vector(7 downto 0);   -- Red channel to source color-MUX with
signal green_sig  : std_logic_vector(7 downto 0);   -- Green channel to source color-MUX with
signal blue_sig   : std_logic_vector(7 downto 0);   -- Blue channel to source color-MUX with

-- Background
signal SHOW_BG    : std_logic;                      -- Signal to apply to color-MUX

-- Control signals dual port RAM
-- Port A
signal write_en_a_sig : std_logic_vector(0 downto 0);
signal addra_sig      : std_logic_vector(3 downto 0);
signal dina_sig       : std_logic_vector(28 downto 0);
signal douta_sig      : std_logic_vector(28 downto 0);
-- Port B
signal write_en_b_sig : std_logic_vector(0 downto 0);
signal addrb_sig      : std_logic_vector(3 downto 0);
signal dinb_sig       : std_logic_vector(28 downto 0);
signal doutb_sig      : std_logic_vector(28 downto 0);
--
signal ADDR_B_1       : std_logic_vector(3 downto 0);  -- Address coming from block_mover
signal ADDR_B_2       : std_logic_vector(3 downto 0);  -- Address coming from block_draw
-- Game logic signals
signal first_block    : std_logic_vector(3 downto 0);  -- Offset where blocks have to be generated (Circular buffer)
signal LOST           : std_logic;                     -- Collision detected, player lost

-- Touch detection signals
signal TOUCH_VALID  : std_logic;                     -- Valid touch detected
signal TOUCH_X      : std_logic_vector(8 downto 0);  -- X-position of touch (valid only if VALID='1')
signal TOUCH_Y      : std_logic_vector(8 downto 0);  -- Y-position of touch (valid only if VALID='1')
signal NEW_X        : std_logic_vector(8 downto 0);  -- Always _valid_ touch signals
signal NEW_Y        : std_logic_vector(8 downto 0);  -- Always _valid_ touch signals

-- Signals for player_driver
signal PLAYER_LANE  : STD_LOGIC_VECTOR(1 downto 0);  -- Current lane the player is in
signal PLAYER_R     : STD_LOGIC_VECTOR(7 downto 0);  -- Red channel to source color MUX with
signal PLAYER_G     : STD_LOGIC_VECTOR(7 downto 0);  -- Green channel to source color MUX with
signal PLAYER_B     : STD_LOGIC_VECTOR(7 downto 0);  -- Blue channel tou source color MUX with
signal PLAYER_V     : STD_LOGIC;                     -- Player visible to apply to color MUX

-- Signal for rand_driver
signal SEED         : STD_LOGIC;                     -- Trigger signal to seed RNG again
signal RAND_NUM     : STD_LOGIC_VECTOR(7 downto 0);  -- Random number generated by rand_driver [0, 255]

---------------------------------------
-- Debug signals
---------------------------------------

-- SPI TAP signals to debug spi-interface
signal CS_I         : STD_LOGIC;
signal DCLK_I       : STD_LOGIC;
signal MOSI_I       : STD_LOGIC;
signal BUSY_I       : STD_LOGIC;
signal MISO_I       : STD_LOGIC;

-- Priority selection for player position to debug touch_driver
signal PRIOR        : STD_LOGIC;
signal RECT_X       : STD_LOGIC_VECTOR(8 downto 0);
signal RECT_Y       : STD_LOGIC_VECTOR(8 downto 0);
signal DRAW         : STD_LOGIC;

begin

---------------------------------------
-- Port mapping of the components
---------------------------------------
b0:             BUFG                    port map (O => P_CLK, I => P_CLK_9MHz);
pll:            PLL_9MHz                port map (CLK=>CLK,RST=>RST,CLK_9MHz=>P_CLK_9MHz);
disp_drive:     display_driver          port map (P_CLK=>P_CLK_9MHz,RST=>RST,H_SYNC=>H_SYNC,V_SYNC=>V_SYNC_SIG,DISP_EN=>DISP_EN,VALID=>VALID,X_POS=>X_POS,Y_POS=>Y_POS);
block_mover:    move_blocks             port map (CLK=>CLK,RST=>RST,V_SYNC=>V_SYNC_SIG,DOUT_B=>doutb_sig,DIN_B=>dinb_sig,WE_B=>write_en_b_sig,ADDR_B=>ADDR_B_2);
block_disp:     draw_blocks             port map (CLK=>CLK,RST=>RST,XPOS=>X_POS,YPOS=>Y_POS,DISP_EN=>VALID,DOUT_B=>doutb_sig,ADDR_B=>ADDR_B_1,SHOW=>DRAW,POS_FIRST=>first_block,LOST=>LOST,LANE=>PLAYER_LANE);
block_ram:      dual_prt_ram_block_strg port map (clka=>CLK,wea=>write_en_a_sig,addra=>addra_sig,dina=>dina_sig,douta=>douta_sig,clkb=>CLK,web=>write_en_b_sig,addrb=>addrb_sig,dinb=>dinb_sig,doutb=>doutb_sig);
block_gen:      block_generator         port map (CLK=>CLK,RST=>RST,RAND_NUM=>RAND_NUM,WRITE_EN_A=>write_en_a_sig,ADDR_A=>addra_sig,DIN_A=>dina_sig,POS_FIRST_O=>first_block);
bg1:            background              port map (CLK=>CLK,X_POS=>X_POS,Y_POS=>Y_POS,VISIBLE=>VALID,SHOW=>SHOW_BG);
spi_driver:     touch_driver_picoblaze  port map (CS=>CS_I, DCLK=>DCLK_I, MOSI=>MOSI_I, VALID=>TOUCH_VALID,BUSY=>BUSY_I, MISO=>MISO_I,CLK=>CLK,RST=>RST, X_POS=>TOUCH_X,Y_POS=>TOUCH_Y);
pd:             player_driver           port map (CLK=>CLK,PCLK=>P_CLK_9MHz,RST=>RST,V_SYNC=>V_SYNC_SIG,VALID=>VALID, X_TOUCH=>NEW_X,Y_TOUCH=>NEW_Y,X_POS=>X_POS,Y_POS=>Y_POS, LANE=>PLAYER_LANE, PLAYER_R=>PLAYER_R,PLAYER_G=>PLAYER_G,PLAYER_B=>PLAYER_B, PLAYER_V=>PLAYER_V, SEED=>SEED);
rng:            rand_driver             port map (SEED => SEED, RAND=>RAND_NUM, CLK=>CLK, RST => RST);

--------------------------------------
-- Control signals display
--------------------------------------

GND<='0';               -- GND
BL_EN<='1';             -- Backlight enable
V_SYNC<=V_SYNC_SIG;     -- Cannot read from output port, MITM

-- SPI TAP signals to debug spi-interface
CS <= CS_I;
DCLK <= DCLK_I;
MOSI <= MOSI_I;
BUSY_I <= BUSY;
MISO_I <= MISO;

-- DEBUGGING TOUCH POSITION
SHOW_BLOCK <= PRIOR or DRAW;

--------------------------------------
-- Processes
--------------------------------------

-- Update touch coordinates when they're valid
update_touch: process(CLK)
    variable xt : unsigned(8 downto 0) := to_unsigned(0, 9);
    variable yt : unsigned(8 downto 0) := to_unsigned(0, 9);
begin
    if (CLK'event and CLK='1') then
        -- Coördinates are valid, update NEW-coordinates
        if (TOUCH_VALID = '1') then
            NEW_X <= TOUCH_X;
            NEW_Y <= TOUCH_Y;
        end if;

        -- DEBUGGING TOUCH DRIVER
        if (V_SYNC_SIG = '0') then
            RECT_X <= NEW_X;
            RECT_Y <= NEW_Y;
        end if;

        xt := unsigned(RECT_X);
        yt := unsigned(RECT_Y);

        if unsigned(X_POS) > xt and unsigned(X_POS) <= xt + to_unsigned(32, 9)
        and unsigned(Y_POS) > yt and unsigned(Y_POS) <= yt + to_unsigned(32, 9) then
            -- Make this value 1 when you want to debug the position of touches
            PRIOR <= '0';
        else
            PRIOR <= '0';
        end if;
    end if;
end process;

--------------------------------------------------------
-- Process to allow multiple drivers for the ADDR_B bus
--------------------------------------------------------

address_mux: process(V_SYNC_SIG)
begin
    if(V_SYNC_SIG = '0')then
        -- Allow block mover to access port B of the dual port RAM
        addrb_sig <= ADDR_B_2;
    else
        -- Allow block drawer to access port B of the dual port RAM
        addrb_sig <= ADDR_B_1;
    end if;--end mux
end process;

-------------------------------------------------------
-- Change color to show the progress
-------------------------------------------------------
change_color: process(CLK)
variable delay: integer range color_delay downto 0;
begin
    if(CLK'event and CLK='1')then
        if(RST ='1')then
            red_sig<=X"FF";
            green_sig<=X"FF";
            blue_sig<=X"FF";
            delay:=0;
        else
            if (delay < color_delay - 1) then
                delay := delay + 1;
            else
                delay := 0;
            end if;

            if (delay = color_delay - 1) then
                if(red_sig = X"00")then
                    if(green_sig = X"00")then
                        if(blue_sig = X"00")then
                            --  Nothing left, reset
                            red_sig<=X"FF";
                            green_sig<=X"FF";
                            blue_sig<=X"FF";
                        else
                            -- Then subtract all blue color
                            blue_sig <= std_logic_vector(unsigned(blue_sig)-1);
                        end if;
                    else
                        -- Secondly, subtract all green color
                        green_sig <= std_logic_vector(unsigned(green_sig)-1);
                    end if;
                else
                    -- First subtract all red color
                    red_sig <= std_logic_vector(unsigned(red_sig)-1);
                end if;
            end if; -- End overflow
        end if; -- End reset
    end if; -- End clock
end process;

-------------------------------------------------------
-- Color MUX
-------------------------------------------------------
show_figure: process(CLK)

    -- Set-reset game-state
    variable lost_int : std_logic:='0';

begin
    if (CLK'event and CLK='1') then
        if(RST='1')then
            lost_int := '0';
        else
            if(LOST ='1' or lost_int = '1') then
                -- Lost screen has priority, show until rst is pressed (Z = 0)
                lost_int := '1';
                RED<=X"FF";
                BLUE<=X"00";
                GREEN<=X"00";
            else
                if (PLAYER_V = '1') then
                    -- Player has second priority (Z = -1)
                    RED <= PLAYER_R;
                    GREEN <= PLAYER_G;
                    BLUE <= PLAYER_B;
                else
                    if (SHOW_BLOCK = '1') then
                        -- Blocks have third priority (Z = -2)
                        RED<=red_sig;
                        GREEN<=green_sig;
                        BLUE<=blue_sig;
                    else
                        if (SHOW_BG = '1') then
                            -- Perspective has fourth (Z = -3)
                            RED <=X"00";
                            GREEN <=X"FF";
                            BLUE<=X"00";
                        else
                            -- Background color (Z = -4)
                            RED <=X"00";
                            GREEN <=X"00";
                            BLUE<=X"00";
                        end if;
                    end if; --end show
                end if; --end player

                --DEBUG SPI ON PMOD C
                --RED <= CS_I & DCLK_I & MOSI_I & BUSY_I & MISO_I & "000";
            end if;  --end lost
        end if; --end reset
    end if; -- end clock
end process;

end Behavioral;
