----------------------------------------------------------------------------------
-- Company: 
-- Engineer: Carleer Jasper & Jelle De Vleesschouwer
-- 
-- Create Date: 11/23/2016 05:22:21 PM
-- Design Name: 
-- Module Name: display_driver - Behavioral
-- Project Name: 
-- Target Devices: 
-- Tool Versions: 
-- Description: 
-- 
-- Dependencies: 
-- 
-- Revision: V1.0
-- Revision 0.01 - File Created
-- Additional Comments:
-- 
----------------------------------------------------------------------------------

--librarys
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_arith.ALL;


entity display_driver is
    Port ( 
           --this should be a 9MHz clock generated by a PLL
           P_CLK : in STD_LOGIC; 
           RST : in STD_LOGIC;
                      
           --signals for the display
           H_SYNC : out STD_LOGIC;
           V_SYNC : out STD_LOGIC;
           DISP_EN : out STD_LOGIC;
           
           --control signals for the algoritme
           VALID : out STD_LOGIC;
           X_POS : out STD_LOGIC_VECTOR (9 downto 0); --only valid if DISP_EN = '1';
           Y_POS : out STD_LOGIC_VECTOR (9 downto 0)  --only valid if DISP_EN = '1';
           
           --Should RGB be placed here? or controlled by the algorithm?
--           RED : out STD_LOGIC_VECTOR (7 downto 0);
--           GREEN : out STD_LOGIC_VECTOR (7 downto 0);
--           BLUE : out STD_LOGIC_VECTOR (7 downto 0)         
           );
           
end display_driver;
------------------------------------------------------------------
--          __    ______________________    __
--            |__|                      |__|
--             A   B         C        D  A 
--          A : pulse width
--          B : front porch
--          C : display period
--          D : back porch
------------------------------------------------------------------

architecture Behavioral of display_driver is

--constants
--constant h_cycle      : integer :=525;
--constant h_disp_period: integer :=480;
--constant h_front_porch: integer :=2;
--constant h_back_porch : integer :=2;
--constant h_pulse_width: integer :=41;

--constant v_cycle      : integer :=286;
--constant v_disp_period: integer :=272;
--constant v_front_porch: integer :=2;
--constant v_back_porch : integer :=2;
--constant v_pulse_width: integer :=10;
constant h_cycle      : integer :=533;
constant h_disp_period: integer :=480;
constant h_front_porch: integer :=8;
constant h_back_porch : integer :=43;
constant h_pulse_width: integer :=2;

constant v_cycle      : integer :=288;
constant v_disp_period: integer :=272;
constant v_front_porch: integer :=4;
constant v_back_porch : integer :=12;
constant v_pulse_width: integer :=10;


begin

sync_generation: process(P_CLK)

--variables
variable horz_count : integer range (h_cycle) downto 0:=0; --total count of a horizontal cycle (datasheet p57)
variable vert_count : integer range (v_cycle) downto 0:=0; --total count of a vertical cycle (datasheet p57)

begin
    if (P_CLK'event and P_CLK='1') then
        if (RST='1') then
            --Reset everything
            horz_count := 0;
            vert_count := 0;
            
            DISP_EN    <= '0';
            H_SYNC     <= '0';
            V_SYNC     <= '0';
            
            VALID      <= '0';
            X_POS      <= (others=>'0');
            Y_POS      <= (others=>'0');
            
--            RED        <= X"00";
--            GREEN      <= X"00";
--            BLUE       <= X"00";
        else 
            ----horizontal----
            
            --increment the horizontal pulse count
            horz_count := horz_count + 1; 
            
            --when you start a new line
            --we have to manually check for an overflow (no automatic wrap around)
            if( horz_count = h_cycle ) then
                horz_count := 0;
                H_SYNC<='0';
                --increment the vertical count because we just reached a new line
                vert_count := vert_count +1; 
            end if;
            
            --stay low for h_pulse_width pulses
            if( horz_count = h_pulse_width ) then 
                H_SYNC <= '1';
            end if;
            
            ----vertical----
            
            --when you start a new screen
            if(vert_count = v_cycle) then
                vert_count := 0;
                V_SYNC<='0';
            end if;
            
            --stay low for v_pulse_width lines
            if(vert_count = v_pulse_width) then
                V_SYNC<='1';
             end if;
            
            ----display region----
            
            --determine if we are in the valid region to display something
            if( ( horz_count >= ( h_pulse_width + h_front_porch ) ) and 
                ( horz_count <  ( h_pulse_width + h_front_porch + h_disp_period ) ) and 
                ( vert_count >= ( v_pulse_width + v_front_porch ) ) and 
                ( vert_count <  ( v_pulse_width + v_front_porch + v_disp_period ))) then
                
                DISP_EN <= '1';
                VALID   <= '1';
                X_POS   <= conv_std_logic_vector((horz_count-h_pulse_width-h_front_porch),10);
                Y_POS   <= conv_std_logic_vector((vert_count-v_pulse_width-v_front_porch),10);
            else
                DISP_EN <= '0';
                VALID   <= '0';
                X_POS   <= (others=>'0');
                Y_POS   <= (others=>'0'); 
            end if;
           
        end if; --end reset
    end if; --end clock
end process;


end Behavioral;
