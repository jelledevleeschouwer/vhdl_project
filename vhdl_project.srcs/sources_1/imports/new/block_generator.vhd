----------------------------------------------------------------------------------
-- Company:
-- Engineer:
--
-- Create Date: 12/10/2016 09:28:19 AM
-- Design Name:
-- Module Name: block_generator - Behavioral
-- Project Name:
-- Target Devices:
-- Tool Versions:
-- Description:
--
-- Dependencies:
--
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
--
----------------------------------------------------------------------------------
--This module should generate a new block every X seconds
--This block is than stored in the dual port ram
--To know where to store the block a circular buffer principle is used

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity block_generator is
    Port (
           CLK        : in STD_LOGIC;
           RST        : in STD_LOGIC;
           RAND_NUM   : in std_logic_vector(7 downto 0);
           WRITE_EN_A : out std_logic_vector(0 downto 0); --write enable for port A of the block ram
           ADDR_A     : out std_logic_vector(3 downto 0); --address to write the data
           DIN_A      : out std_logic_vector(28 downto 0); --data to write to the block ram
           POS_FIRST_O: out std_logic_vector(3 downto 0) --used to create a circular buffer

           );
end block_generator;

architecture Behavioral of block_generator is
--parameters --449999999
constant prescale_count_limit          : integer :=149999999; --rate at which the blocks are added -> 3seconden
constant last_block                    : integer :=9; --index of the last element in the block ram
--signals
signal put_block     : std_logic; --put_block is one when we should add a new block to the DUAL PORT RAM

begin

prescaler: process(CLK)
variable count_value : integer range prescale_count_limit downto 0:=0;

begin
    if(CLK'event and CLK='1')then
        if(RST='1')then
            put_block <= '0';
            count_value := 0;
        else
            count_value := count_value + 1; --increment count_value by one
            if(count_value = prescale_count_limit) then
                put_block <= '1'; --make put_block '1' for one clock pulse
                count_value := 0;
            else
                put_block <= '0';
            end if; --end delay
        end if; --end reset
    end if; --end clock

end process;

add_block: process(CLK)
variable pos_first : integer range 10 downto -1:=0; --variable to know the position of the first block
variable initialise : std_logic:='1';
variable init_counter: integer range 10 downto 0:=0;
variable rand: unsigned(7 downto 0);
begin
    if(CLK'event and CLK='1')then
        if(RST ='1')then
           pos_first := 0;
           initialise := '1';
           init_counter := 0;
           WRITE_EN_A <="0";
        else

            --routine to initialise the block ram
            if(initialise = '1')then

                --initialise the block ram with zero values
                ADDR_A<=std_logic_vector(to_unsigned(init_counter,4));
                DIN_A<="00000000000000000000000000000";
                WRITE_EN_A <= "1";
                init_counter := init_counter + 1;
                if(init_counter = 10)then
                    initialise := '0'; --done initialising
                end if;

            else

                --every time a pulse is generated by the prescaler put a new block in the block ram
                if(put_block = '1')then
                    ADDR_A<=std_logic_vector(to_unsigned(pos_first,4));
                    POS_FIRST_O <= std_logic_vector(to_unsigned(pos_first,4));

                    --!!here we should place a random generator!!
                    rand := unsigned(RAND_NUM);
                    if (rand > 0 and rand <= 85) then
                        DIN_A <= "010010000" & "011010000" & "001100000" & "01";
                    elsif (rand > 85 and rand <= 170) then
                        DIN_A <= "011010000" & "100010000" & "001100000" & "10";
                    else
                        DIN_A <= "100010000" & "101010000" & "001100000" & "11";
                    end if;

                    pos_first := pos_first - 1; --place the new block before the previous one
                    if(pos_first = -1)then
                        pos_first := 9;
                    end if;

                    WRITE_EN_A <= "1";
                else
                    WRITE_EN_A <= "0";
                end if; --end put block
            end if; --end initialise
        end if; --end reset
    end if;--end clock

end process;


end Behavioral;
