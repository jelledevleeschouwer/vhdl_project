----------------------------------------------------------------------------------
-- Company: 
-- Engineer: 
-- 
-- Create Date: 12/10/2016 09:28:19 AM
-- Design Name: 
-- Module Name: block_generator - Behavioral
-- Project Name: 
-- Target Devices: 
-- Tool Versions: 
-- Description: 
-- 
-- Dependencies: 
-- 
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
-- 
----------------------------------------------------------------------------------
--This module should generate a new block every X seconds
--This block is than stored in the dual port ram
--To know where to store the block a circular buffer principle is used

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity block_generator is
    Port ( 
           CLK        : in STD_LOGIC;
           RST        : in STD_LOGIC;
           
           WRITE_EN_A : out std_logic_vector(0 downto 0); --write enable for port A of the block ram
           ADDR_A     : out std_logic_vector(3 downto 0); --address to write the data 
           DIN_A      : out std_logic_vector(28 downto 0); --data to write to the block ram
           POS_FIRST_O: out std_logic_vector(3 downto 0) --used to create a circular buffer
           
           );
end block_generator;

architecture Behavioral of block_generator is
--parameters --449999999
constant prescale_count_limit          : integer :=149999999; --rate at which the blocks are added -> 3seconden
constant last_block                    : integer :=9; --index of the last element in the block ram
--signals
signal put_block     : std_logic; --put_block is one when we should add a new block to the DUAL PORT RAM

begin

prescaler: process(CLK)
variable count_value : integer range prescale_count_limit downto 0:=0;  

begin
    if(CLK'event and CLK='1')then
        if(RST='1')then
            put_block <= '0';
            count_value := 0;
        else
            count_value := count_value + 1; --increment count_value by one
            if(count_value = prescale_count_limit) then
                put_block <= '1'; --make put_block '1' for one clock pulse
                count_value := 0;
            else
                put_block <= '0';
            end if; --end delay
        end if; --end reset
    end if; --end clock

end process;

add_block: process(CLK)
variable pos_first : integer range 10 downto -1:=0; --variable to know the position of the first block
variable initialise : std_logic:='1';
variable init_counter: integer range 10 downto 0:=0;
variable lane: integer range 3 downto 1 :=1; --remove this if the random gen is ready

begin
    if(CLK'event and CLK='1')then
        if(RST ='1')then
           pos_first := 0;
           initialise := '1';
           init_counter := 0;
           WRITE_EN_A <="0";
           lane:=1; --remove this if the random gen is ready
        else
        
            --routine to initialise the block ram
            if(initialise = '1')then
            
                --initialise the block ram with zero values
                ADDR_A<=std_logic_vector(to_unsigned(init_counter,4));
                DIN_A<="00000000000000000000000000000";
                WRITE_EN_A <= "1";
                init_counter := init_counter + 1;
                if(init_counter = 10)then
                    initialise := '0'; --done initialising
                end if;
                
            else
            
                --every time a pulse is generated by the prescaler put a new block in the block ram
                if(put_block = '1')then
                    ADDR_A<=std_logic_vector(to_unsigned(pos_first,4));
                    POS_FIRST_O <= std_logic_vector(to_unsigned(pos_first,4));
                    
                    --!!here we should place a random generator!!
                    case lane is
                        when 1=> lane := lane + 1;
                                 DIN_A <= "010010000" & "011010000" & "001100000" & "01";
                        when 2=> lane := lane + 1;
                                 DIN_A <= "011010000" & "100010000" & "001100000" & "10";
                        when 3=> lane := 1;
                                 DIN_A <= "100010000" & "101010000" & "001100000" & "11";
                        when others => lane := 1;
                    end case;
                    
                    pos_first := pos_first - 1; --place the new block before the previous one
                    if(pos_first = -1)then
                        pos_first := 9;
                    end if;
                    
                    WRITE_EN_A <= "1";
                else
                    WRITE_EN_A <= "0";
                end if; --end put block
            end if; --end initialise
        end if; --end reset    
    end if;--end clock
    
end process;
  
    
end Behavioral;
