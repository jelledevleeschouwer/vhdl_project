----------------------------------------------------------------------------------
-- Company:
-- Engineer:
--
-- Create Date: 12/10/2016 09:28:19 AM
-- Design Name:
-- Module Name: block_generator - Behavioral
-- Project Name:
-- Target Devices:
-- Tool Versions:
-- Description:
--
-- Dependencies:
--
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
--
----------------------------------------------------------------------------------
--This module should generate a new block every X seconds
--This block is than stored in the dual port ram
--To know where to store the block a circular buffer principle is used

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity block_generator is
    Port (
        CLK        : in STD_LOGIC;                      -- 125 MHz
        RST        : in STD_LOGIC;

        -- Signal relating generating blocks
        RAND_NUM   : in std_logic_vector(7 downto 0);   -- Random number, generated by PRNG
        WRITE_EN_A : out std_logic_vector(0 downto 0);  -- Write enable for port A of block RAM
        ADDR_A     : out std_logic_vector(3 downto 0);  -- Address to write the data
        DIN_A      : out std_logic_vector(28 downto 0); -- Data to write to the block ram
        POS_FIRST_O: out std_logic_vector(3 downto 0)   -- Offset where blocks have to be generated (Circular buffer)
    );
end block_generator;

architecture Behavioral of block_generator is

    -- Constants
    constant prescale_count_limit: integer := 150000000; -- Rate at which the blocks are added: 1seconden
    constant last_block: integer := 9; -- Index of the last element in the block ram

    -- Signals
    signal put_block : std_logic; -- Put_block is when we should add a new block to the DUAL PORT RAM

begin

prescaler: process(CLK)

    -- Prescaler
    variable count_value : integer range prescale_count_limit downto 0:=0;

begin
    if(CLK'event and CLK='1')then
        if (RST = '1') then
            put_block <= '0';
            count_value := 0;
        else
            if (count_value < prescale_count_limit - 1) then
                count_value := count_value + 1;
            else
                count_value := 0;
            end if;

            if (count_value = prescale_count_limit - 1) then
                put_block <= '1';
            else
                put_block <= '0';
            end if;
        end if; -- End reset
    end if; -- End clock

end process;

add_block: process(CLK)
    variable pos_first: integer range 10 downto -1 := 0; -- Variable to know the position of the first block
    variable initialise: std_logic:='1';
    variable init_counter: integer range 10 downto 0:=0;
    variable rand: unsigned(7 downto 0);
begin
    if (CLK'event and CLK='1') then
        if(RST = '1')then
           pos_first := 0;
           initialise := '1';
           init_counter := 0;
           WRITE_EN_A <="0";
        else

            -- Routine to initialise the block ram
            if (initialise = '1') then

                -- Initialise the block ram with zero values
                ADDR_A <= std_logic_vector(to_unsigned(init_counter, 4));
                DIN_A <= "00000000000000000000000000000";
                WRITE_EN_A <= "1";
                init_counter := init_counter + 1;
                if (init_counter = 10) then
                    initialise := '0'; -- Done initialising
                end if;

            else

                -- Every time a pulse is generated by the prescaler put a new block in the block ram
                if (put_block = '1') then
                    -- Apply destination address to dual port RAM
                    ADDR_A <= std_logic_vector(to_unsigned(pos_first, 4));
                    POS_FIRST_O <= std_logic_vector(to_unsigned(pos_first, 4));

                    rand := unsigned(RAND_NUM); -- RAND_NUM is in range [0, 255], split in 3
                    if (rand > 0 and rand <= 85) then
                        DIN_A <= "010010000" & "011010000" & "001100000" & "01";
                    elsif (rand > 85 and rand <= 170) then
                        DIN_A <= "011010000" & "100010000" & "001100000" & "10";
                    else
                        DIN_A <= "100010000" & "101010000" & "001100000" & "11";
                    end if;

                    pos_first := pos_first - 1; -- Place the new block before the previous one
                    if (pos_first = -1) then
                        pos_first := 9;
                    end if;

                    -- Write strobe
                    WRITE_EN_A <= "1";
                else
                    WRITE_EN_A <= "0";
                end if; -- End put block
            end if; -- End initialise
        end if; -- End reset
    end if; -- End clock

end process;

end Behavioral;
